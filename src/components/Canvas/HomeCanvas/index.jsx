import React, { Suspense, useEffect, useRef, useState } from "react";
import {
  OrthographicCamera,
  PerspectiveCamera,
  Stars,
} from "@react-three/drei";
import { extend } from "@react-three/fiber";
import * as THREE from "three";
import { Canvas, useFrame } from "@react-three/fiber";
import {
  Environment,
  useGLTF,
  ContactShadows,
  OrbitControls,
  useIntersect,
} from "@react-three/drei";
import { motion } from "framer-motion-3d";
import { useProgress } from "@react-three/drei";

export default function HomeCanvas() {
  const { progress } = useProgress();
  useEffect(() => {
    console.log(progress);
  }, [progress]);
  return (
    <>
      <PerspectiveCamera makeDefault position={[0, 0, 30]} />
      <Stars
        count={10000}
        depth={265.14}
        factor={0}
        radius={8.12}
        saturation={30.44}
        speed={1.2}
      />
      <BasicModel />
      <HeavyModel />
    </>
  );
}

function BasicModel(props) {
  const ref = useIntersect((visible) =>
    console.log("object is visible", visible)
  );
  return (
    <mesh ref={ref} {...props} dispose={null}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial color="hotpink" />
    </mesh>
  );
}

function HeavyModel() {
  const { scene, nodes } = useGLTF("/heave-car.glb");
  return <primitive object={scene} scale={1} />;
}

function Model() {
  const visible = useRef(false);
  const [hovered, hover] = useState(false);
  const ref = useIntersect((visible) =>
    console.log("object is visible", visible)
  );
  // Load model
  const { nodes, materials, scene } = useGLTF("/heave-car.glb");
  // Make it float

  useFrame((state) => {
    console.log(nodes);
    const t = state.clock.getElapsedTime();
    ref.current.rotation.x = THREE.MathUtils.lerp(
      ref.current.rotation.x,
      Math.cos(t / 2) / 20 + 0.25,
      0.1
    );
    ref.current.rotation.y = THREE.MathUtils.lerp(
      ref.current.rotation.y,
      Math.sin(t / 4) / 20,
      0.1
    );
    ref.current.rotation.z = THREE.MathUtils.lerp(
      ref.current.rotation.z,
      Math.sin(t / 8) / 20,
      0.1
    );
    ref.current.position.y = THREE.MathUtils.lerp(
      ref.current.position.y,
      (-2 + Math.sin(t / 2)) / 2,
      0.1
    );
  });
  // The jsx graph was auto-generated by: https://github.com/pmndrs/gltfjsx
  useEffect(() => {
    console.log(true, true, " answer: " + visible.current);
    console.log(nodes);
  }, [visible.current]);
  return (
    <motion.group>
      <group rotation-x={-0.425} position={[0, -0.04, 0.41]}>
        <group
          ref={ref?.current ? ref : null}
          position={[0, 2.96, -0.13]}
          rotation={[Math.PI / 2, 0, 0]}
        >
          <motion.mesh
            initial={{ scale: 0 }}
            animate={{ scale: visible.current ? 20 : 0.5 }}
            transition={{ duration: 10 }}
            ref={ref?.current ? ref : null}
            material={materials.aluminium}
            geometry={nodes["Cube008"].geometry}
          ></motion.mesh>
          <mesh
            material={materials["matte.001"]}
            geometry={nodes["Cube008_1"].geometry}
          />
          <mesh geometry={nodes["Cube008_2"].geometry}>
            {/* Drei's HTML component can "hide behind" canvas geometry */}
          </mesh>
        </group>
      </group>
      <mesh
        material={materials.keys}
        geometry={nodes.keyboard.geometry}
        position={[1.79, 0, 3.45]}
      />
      <group position={[0, -0.1, 3.39]}>
        <mesh
          material={materials.aluminium}
          geometry={nodes["Cube002"].geometry}
        />
        <mesh
          material={materials.trackpad}
          geometry={nodes["Cube002_1"].geometry}
        />
      </group>
      <mesh
        material={materials.touchbar}
        geometry={nodes.touchbar.geometry}
        position={[0, -0.03, 1.2]}
      />
    </motion.group>
  );
}
